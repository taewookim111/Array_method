/*
배열이란
여러개의 값을 인덱스로 나열한 자료구조
배열이 가지고 있는 값을 요소라고 합니다
이 요소에는 값으로 인정하는 모든 것이 올 수 있습니다
let sum = [1, 2, 3, 4, 4+3, function(){}];
표현식, 함수등도 값으로 인정되기 때문에 요소가 될 수 있습니다

자바스크립트 배열의 특징
일반 자료의 구조에서 말하는 배열은 밀집배열이라고 합니다
밀집배열은 동일한 데이터 크기가 빈틈없이]
연속적으로 이어져 있는 구조입니다
자바스크립트 배열은 각 메모리 공간이 동일한 크기가 아니고,
연속적으로 메모리 공간이 이어져 있지도 않습니다
또 희소배열을 포함하기도 합니다
결론적으로 js배열은 일반적인(자료구조의) 배열을 흉내낸 특수객체이다
즉 인덱스라는 문자열을 프로퍼티의 이름(key)를 가지고
해당요소의 값을 이어서 가지는 특수 객체입니다

희소배열이란?
빈 값이 있는 배열을 뜻합니다
할당되지 않는 인덱스에 초기값 undefined를 넣은 배열,
이 배열은 반복문을 돌릴 때 문제가 됩니다, 비어있는 값은 반복을 못함
const arr = [1, ,3];
console.log(arr);
console.log(arr[1]);

결론 js 배열은 특이하다. => 객체이다
js배열은 빠른 접근을 포기하고, 빠른 요소의 삽입, 삭제, 편집을
추구한 것

배열의 생성 방법
//배열리터럴로 생성하는 방법
const arr = [1,2,3];
//빈배열을 선언하여 만들고, 배열의 값을 이후에 하나씩 넣는 방법
const arr1 = [];
arr[0] = 1;
arr[1] = 2;
//배열 생성자(생성함수)로 만드는 방법
const arr2 = new Array();
//==> const arr1 = [];
const arr3 = new Array(1, 2, 3);
//==> const arr = [1, 2, 3];
// + 유사배열을 배열로 만드는 방법
const arr3 = Array.from(유사배열이름)

배열의 요소를 참조하는 방법
참조할때 대괄호 표기법을 사용해서 참조합니다
대괄호에는 인덱스를 씁니다
정수로 평가되는 표현식이라면 인덱스 위치에 올 수 있습니다
만약 정수값이 아닌경우, 오류는 나지 않습니다만
이렇게되면 요소가 생성된 것이 아니라 프로퍼티가 생성됩니다
const arr = []
arr[0] = 1;
arr["1"] = 2;
arr[1.4] = 3;
arr["apple"] = "핸드폰";
//1.4라는 프로퍼티 이름과, 값 3으로 들어간 것이고, 배열의 요소는 아님
보통은 정수가 아닌값을 넣지 않습니다
하지만 실수롤 정수가 아닌 실수를 넣을 경우 오류가 나지 않아
개발자가 알 수 없으므로 주의요함
예) 5개의 요소를 넣기로 했는데 실수로 마지막 요소를 정수가 아닌
실수값을 넣으면, 오류가 나지 않아서 개발자는 깨닫지 못하고
이 상태에서 반복문이나 기타 배열관련 메소드를 사용하면
원하는 값을 얻지 못하게 됩니다
따라서 배열의 길이를 꼭 먼저 알아야합니다
그래서 실무에서는 배열을 반복을 돌거나 기타 메소드를 적용할때
먼저 배열의 길이부터 측정합니다

배열의 메소드
1.indexOf
const arr = [1, 2, 2, 3];
console.log(arr.indexOf(2)); //1(인덱스)
//배열 arr에서 요소 2를 처음부터 검색해서 첫번째로 검색된 요소의
//인덱스를 반환하고 종료합니다
console.log(arr.indexOf(7));
//배열 arr에서 요소 7이 없으므로 -1을 반환합니다
//따라서 배열에 해당요소가 있다면, 양의 정수가 반환되고 그 정수는
//해당 인덱스를 의미하며, 없으면 -1을 무조건 반환합니다

console.log(arr.indexOf(2, 2));
//두 번째 값으로 인덱스(순번)을 적으면, 검색을 시작할 인덱스를 지정
//따라서 2인덱스 부터 2요소를 찾고 그 찾은 인덱스를 반환하게 됩니다
//만약 두 번째 값인 시작할 인덱스를 생략하면 처음부터 찾는 것입니다

2. push
const arr = [1, 2, 2, 3];
console.log(arr.push(3,4));
//push에 넣은 값을 원본배열 arr의 마지막 요소에 추가하고
//변경된 arr.length를 반환합니다
console.log(arr);
//이 메소드는 원본배열을 직접 변경합니다
//만약 push로 추가할 요소가 하나라면 다른 방법으로 추가할 수 있습니다
arr[arr.length] = 3;
//arr이라는 배열의 길이를 인덱스로 넣어서 가장마지막이라는 뜻으로
//사용하여 push가 가진뜻 가장 마지막 인덱스에 추가한다는 뜻을
//다른방법(배열을 참조하는 방법)으로 충족한 것

3. pop
const arr = [1, 2, 2, 3];
console.log(arr.pop());
//배열 arr의 가장 마지막 요소인 3을 제거하고 제거한 요소인
//3을 반환합니다
console.log(arr);
//원본배열을 직접 변경합니다

4. unshift
const arr = [1, 2, 2, 3];

console.log(arr.unshift(3,4));
//배열 arr에 선두에 값을 추가하고 변경된 배열의 길이를 반환합니다
console.log(arr);
//원본 배열을 직접 변경합니다

5. shift
const arr = [1, 2, 2, 3];
console.log(arr.shift());
//배열 arr의 첫 번째 요소를 제거하고, 제거한 요소를 반환합니다
console.log(arr);
//원본 배열을 직접 변경합니다

6. concat
const arr1 = [1, 2];
const arr2 = [3, 4];
//console.log(arr1.concat(arr2)); //[1, 2, 3, 4]
console.log(arr1.concat(arr2,"a")); //[1, 2, 3, 4, 'a']
//배열을 합쳐서 새로운 배열을 반환합니다
//추가되는 값으로 배열도 올 수 있지만 원시값도 넣을 수 있습니다
console.log(arr1);
console.log(arr2);
//원본 배열은 변경되지 않습니다

[1, 2, 3, 4]
[3, 4, 1, 2]
//push와 unshift대신 concat으로 대체작성이 가능합니다
//push와 unshift는 원본배열을 직접 변경하지만
//concat은 원본배열을 변경하지 않습니다

// const arr1 = [3, 4];
// arr1.unshift(1,2);
// arr1.push(5,6);
// console.log(arr1);
// //원본이었던 arr1은 훼손되어 [1,2,3,4,5,6]

// const arr2 = [3, 4];
// let arr3 = [1,2].concat(arr2);
// arr3 = arr3.concat(5, 6);
// console.log(arr3);
// console.log(arr2);
//원본이었던 arr2는 보존되면서, 새로 추가되어 만들어진 arr3로 생김

const arr2 = [3, 4];
// const arr3 = [1,2].concat(arr2);
// const로 적용해도 각각의 값이 참조형자료이면 변경이 자유롭지만
let arr3 = [1, 2].concat(arr2);
arr3 = arr3.concat(5, 6);
//const 상태에서는 원시형자료형태로 5, 6을 넣게되면
//const 상태이기 때문에 타입에러가 발생합니다
//따라서 let으로 선언을 하거나, 혹은 (5, 6)을 원시형이 아닌
//배열을 만든 뒤 참조형 자료로 추가하면 해결됩니다
console.log(arr3);

7. splice
// const arr = [1,2,2,3];
// const res = arr.splice(1,2,4,5);
//배열.splice
//(시작할인덱스,몇개를 제거할지의 갯수, (제거한 자리에)추가할 요소들);
//console.log(arr); //[1, 4, 5, 3]
//1인덱스부터 2개의 요소를 삭제하고, 4,5를 추가하여 원본배열에 적용
//console.log(res); //[2, 2] 
//제거한 값을 배열로 반환

//시작할 인덱스 : 시작할 인덱스만 적게되면 원본배열의 시작한 요소부터
// 모든 요소를 제거하고 제거한 인덱스 반환합니다

const arr = [1, 2, 2, 3];
//const res = arr.splice(2);
//2인덱스로 시작해서 뒤에 모두를 제거합니다
//따라서 원본배열은 [1,2]만 남게되고
//반환 배열은 삭제한요소 [2,3]을 반환합니다

// const res = arr.splice(-1);
//시작할 인덱스에 음수를 적는게 가능한데 이때 -1을 쓰게되면
//원본배열의 가장 마지막 요소를 가르키는 것
// -n은 마지막에서 n번째를 가리키는 것
//요소가 많아서 뒤에서부터, 카운팅이 더 효율적인 경우 사용합니다
// console.log(arr);
// console.log(res);

//몇개를 제거할지의 갯수
//옵션 : 즉 생략이 가능합니다
//0인경우 아무요소 제거하지 않습니다

//const res = arr.splice(1,0,7); [1, 7, 2, 2, 3]
//const res = arr.splice(1,7); //[1]
//원본 배열에서 1인덱스에 0개의 요소를 제거하고 그 자리에
//새로운 요소 7을 삽입하는 뜻
//0개의 요소를 제거한다는 의미지만 0을 안쓰면 뒤에오는 추가할 요소
//가 숫자인경우, 지우는 갯수로 받아들여서 숫자만큼 지워버림
//지우지 않으려면 0을 써야합니다
// console.log(arr);
// console.log(res);

//(제거한 자리에)추가할 요소들
//옵션 : 생략가능, 생략했을경우 제거만 한다는 의미

const res = arr.splice(1, 1);
//추가목록이 없으면 1인덱스로부터 1개를 제거만 한다
console.log(arr);
console.log(res);

8. slice
splice와 주의~
splice와 달리 slice 는 원본배열 영향을 주지 않습니다
값을 적으면 전달됨 범위의 요소를 복사해서 새 배열을 반환합니다

const arr = [1, 2, 2, 3];
// const res = arr.slice(0, 1); //[1]
//배열.slice(복사를 시작할 인덱스, 복사를 종료할 인덱스(미만취급))
// console.log(arr);
// console.log(res);

// 복사를 시작할 인덱스
// splice와 마찬가지로 음수가 가능하고, -1이 맨마지막 요소입니다
// -n하면 마지막에서 n번째요소, 요소가 많을 경우 사용합니다

//복사를 종료할 인덱스 :
//미만으로 표현된다. 즉 4를 적으면 3까지만 적용한다
//생략이 가능하며, 생략하면 복사를 시작할 인덱스로부터 배열의 끝까지
const res = arr.slice(0, 1);
console.log(arr);
console.log(res);

9.  join
원본 배열의 모든 요소를 문자열로 변환한 후
구분자 (기본값은 ,)로 연결한 문자열을 반환합니다
const arr = [1, 2, 2, 3];
console.log(arr.join());
console.log(arr.join(""));
console.log(arr.join("*"));

10. reverse
원본 배열의 순서를 반대로 뒤집으며, 뒤집은 배열을 반환합니다
원본배열이 변경됩니다

const arr = [1,2,2,3];
arr.reverse();
console.log(arr); [3, 2, 2, 1]

11.fill
전달받은 값을 배열의 요소로 처음부터 끝까지 채웁니다
원본 배열은 변경됩니다
const arr = [1, 2, 2, 3];

//arr.fill("a");  //['a' ,'a', 'a', 'a']
//arr.fill("a", 1);
//두 번째 값을 넣으면 요소 채우기를 시작할 인덱스를 쓸 수 있습니다
arr.fill("a", 1, 2);
//세 번째 값을 넣으면 요소 채우기를 멈출 인덱스를 쓸 수 있습니다
console.log(arr);

//fill 메서드를 사용해서 배열 생성하고, 이후 특정값으로 요소를 모두
//채울 수 있습니다
const creArr = new Array(4); //[empty x 4]
console.log(creArr);
// [] //배열의 길이가 정해지지 않았음
// [,,,] //배열의 길이가 4칸으로 정해진 상태
const res = creArr.fill("apple");
console.log(res); //['apple', 'apple', 'apple', 'apple']
//const creArr = new Array(); //[]
//완전 비어진 상태의 배열이라면
//채우는 범위가 없으므로 채워지지 않습니다
// console.log(creArr);
// const res = creArr.fill("apple"); //[]
// console.log(res);

12. includes
const arr = [1, 2, 2, 3];
console.log(arr.includes(2));
//배열 내의 특정요소가 포함되어 있는지를 확인해서 불린값으로 반환
//=>조건문에 넣기에 알맞음
console.log(arr.includes(2, 3));
//배열 내에서 특정요소 2를 찾는데 3인덱스부터 찾으라는 명령입니다
//3인덱스부터는 2가 없으므로 false반환

//배열에서 인수로 전달된 요소를 검색해서 인덱스를 반환하는 메소드는
//indexOf 메서드였습니다. 이때는 특정 인덱스 정수의 값을 반환하거나
//없는 경우 -1을 반환했습니다
//반면 includes는 불린값을 반환합니다
//NaN (Not a Number)
//만약 해당 배열에 NaN이 포함되어있으면 includes는 배열 안의 요소로
//인식하여 찾을 수 있으나
//indexOf는 NaN을 요소로 인식을 하지 못해서 찾을 수 없습니다

const foods = ["apple", "banana", "orange"];

if(foods.indexOf("orange") === -1){
    console.log("오렌지가 없어요");
}else{
    console.log("오렌지가 맛있어요");
}
//실습
//includes 로 변경해보세요~
//indexOf === -1값이라는 것은 없다는 부정의의미입니다
//따라서 기본 긍정의 의미인 includes와 같으려면
//부정을 해주어야 합니다 따라서 ! 부정의 논리연산자를 사용
if(!foods.includes("orange")){
    console.log("오렌지가 없어요");
}else{
    console.log("오렌지가 맛있어요");
}
//긍정의 의미를 그대로 사용하려면 논리의 흐름이 반대가 되어야합니다
//따라서 오렌지 맛있어요가 참영역으로 오게됩니다
if(foods.includes("orange")){
    console.log("오렌지가 맛있어요");
}else{
    console.log("오렌지가 없어요");
}

=== 불변성
데이터가 변경되지 않고 원본 데이터가 보존되는 원칙을 의미합니다
배열의 불변성을 유지하는 것은 코드의 예측 가능성과, 유지보수성을
향상시키며, 버그를 줄일 수 있어서 안전한 코딩을 할 수 있게 도와줍니다

=== 자바스크립트에서 불변성??
1. 예측가능성 : 예상치 못한 부작용을 줄일 수 있음
2. 디버깅과 유지보수 : 원본배열이 있다는 것은, 버그가 나거나 유지보수
중에 반환배열(변경된)의 비교를 통해서 버그를 찾아내거나, 실수를 찾거나
업데이트(유지보수)를 함에 있어 큰 도움을 줍니다
3. 함수형프로그래밍 : 자바스크립트는 함수형 프로그래밍을 지향하며
이는 상태변경을 피하고, 데이터 변환을 함수의 조합으로 표현하고자 하는
프로그래밍 철학입니다.
따라서 자바스크립트는 불변성을 지켜서 함수형 프로그래밍을 하려고
노력합니다
4.성능최적화 : 이중(원본배열, 반환배열)으로 병행작업을
할 경우 좀 더 작업이 쉽고 성능을 최적화 시킬 수 있습니다
5. react(라이브러리) : 불변성이 중요한 라이브러리와
효율적인 통합관리로서의 필요성이 있습니다

리얼돔 : document를 직접 구현한 DOM을 의미
가상돔 : document에는 없을 수 있는 js에서 앞으로(미래시)
생성될거라 예상하는 시나리오의 DOM의 모습

배열의 고차함수
1. sort
배열의 요소를 정렬하며, 원본배열을 직접 변경하고 정렬된 배열을 반환
기본적으로 오름차순으로 정렬합니다
const foods = ["apple", "orange", "banana"];

const res = foods.sort();
console.log(foods);
console.log(res); //['apple', 'banana', 'orange']

//내림차순으로 하고 싶다면, 먼저 sort로 오름차순 정렬이후
//reverse를 이용합니다
const res2 = foods.reverse();
console.log(res2);//['orange', 'banana', 'apple']
//여기까지가 문자에 관련한 sort입니다

const point = [40, 100, 1, 5, 2, 25, 10];
// point.sort();
// console.log(point);
//숫자 정렬은 유니코드로 정렬합니다
//예) 1은 유니코드로 U+0031, 10 U+0031U+0030
//그런데 2는 U+0032
//이런 이유로 숫자 정렬은 비교함수를 생성해서 정렬순서를 정의해주여야함
//비교함수 적용 sort코드
point.sort(function(a,b){return a - b})
console.log(point); //[1, 2, 5, 10, 25, 40, 100]
//오름차순으로 숫자정렬

point.sort(function (a, b) { return b - a})
console.log(point); //[100, 40, 25, 10, 5, 2, 1]
//내림차순으로 숫자정렬

console.log(point[0],point[point.length - 1])
//이런 숫자 sort가 의미를 가지는 이유는
//최대, 최솟값을 바로 찾을 수 있습니다
//즉 양 끝단의 값이 각각 최대, 최소가 됩니다

2. forEach
고차함수로써의 forEach.
원본배열은 변경되지 않습니다
반복문을 대체할 수 있으며, 배열이 아닌 유사배열에도 사용할 수 있음
또 모든 요소들을 순차적으로 접근하여 콜백함수를 적용하는데
순회하면서 접근하므로 중간에 멈추거나 중단할 수 없습니다
(즉, break, continue)둘다 중단하여 break는 코드 하단으로,
continue는 코드 위로(시작지점) 보내는데 forEach는 할 수 없다
장점 : 유사배열 사용가능, index개념 추가가능
기본for문에 비해서 가독성이 좋음 
3. map
고차함수로써의 map
원본배열은 변경되지 않으면서 콜백함수에 적용된 요소들을
새배열로 반환합니다.
js의 배열은 특별한 객체, 인덱스 = 이름, 요소 = 값으로 된
프로퍼티라고 했습니다
map은 호출한 원본배열과 생성반환된 배열이 1:1로 해당 프로퍼티가
반드시 일치합니다
이것은 불변성에서 큰 의미를 가지는 중요한 속성입니다

4.filter
map의 접근방법과 비슷하지만, map은 모든 요소에 순차적으로 접근해서
콜백함수를 적용시키고, 그 요소들을 새배열로 반환하는 반면
filter는 콜백함수를 적용시킬 때 true의 값으로 평가되는 요소만
모아서 새로운 배열로 반환합니다

const point = [40, 100, 1, 5, 2, 25, 10];
const odds = point.filter(function(el, index){ return el % 2 });
//각 요소들은 0 아니면 1의 값을 가질 것입니다
//1은 true로 평가되기 때문에 1의 값을 가지는 홀수만 배열요소로 반환
console.log(odds); //[1, 5, 25]

//짝수를 구하려면?? 어떻게 코드를 수정하면 될까요?

const even = 
point.filter(function(el, index){ return el % 2 === 0});
//{}안의 내용이 참이되는 요소가 짝수이어야하므로
//나머지가 0인 것을 물어보고 참이면 배열요소로 묶어 반환하면 됩니다
console.log(even); 

5. find
find는 filter와 비슷합니다
즉 배열의 요소를 순회하면서 콜백함수의 true값을 반환하는데
오직 첫 true만 반환합니다
const point = [40, 100, 1, 5, 2, 25, 10];
const odds = point.find(function(el, index){ return el % 2 });
console.log(odds); //1만 반환됨

6. findIndex
말 그대로 find는 요소를 반환했다면, 이것은 인덱스를 반환합니다
즉 배열의 요소를 순회하면서 콜백함수의 true값을 반환하는
해당 요소의 인덱스를 반환합니다
const point = [40, 100, 1, 5, 2, 25, 10];
const odds = point.findIndex(function(el, index){ return el % 2 });
console.log(odds); //2 인덱스가 출력됨
*/













